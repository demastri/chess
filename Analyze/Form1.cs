using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using ChessPosition;

namespace Analyze
{
    public partial class AnalyzeForm : Form
    {
        List<Game> GameRef;

        Dictionary<PositionHash, Analysis> totalAnalysis;
        Dictionary<PositionHash, int> repetitionCount;
        Engine AnalysisEngine = null;
        int curAnalysisPositionIndex = -1;
        DateTime curAnalysisStartTime;
        TimeSpan posAnalysisTimeLimit;
        bool runningAnalysis;
        int completedAnalysisRequests;
        AnalysisFarmClient thisFarmClient = null;
        AnalysisFarm thisFarm = null;
        DateTime farmStartTime;
        EngineParameters globalEngineParameters;

        public AnalyzeForm()
        {
            InitializeComponent();
        }

        private void OpenMenuItem_Click(object sender, EventArgs e)
        {
            if (openFileDialog1.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                string PGNFileLoc = openFileDialog1.FileName;
                PGNLoc.Text = PGNFileLoc;
                GameRef = Game.ReadPGNFile(PGNFileLoc);
                FileStatsButton_Click(null, null);
            }
            else
            {
                PGNLoc.Text = "";
                TotalGamesLabel.Text = "Total Games: ---";
                TotalRatedLabel.Text = "Total Rated: ---";
                TotalPliesLabel.Text = "Total Plies: ---";
                UniquePosLabel.Text = "Unique Pos: ---";
            }
        }


        private void AnalysisButton_Click(object sender, EventArgs e)
        {
            string EngineName = "Stockfish";
            int depth = Convert.ToInt32(depthEntry.Text);
            int time = (depth != -1 ? -1 : Convert.ToInt32(timeEntry.Text));
            globalEngineParameters = new EngineParameters(EngineName, depth, time);

            if (UseFarm.Checked)
                AnalyzeViaFarm();
            else
                AnalyzeViaEngine();
        }
        private void AnalyzeViaFarm()
        {
            if (thisFarm != null)
            {
                thisFarm.Shutdown();
                thisFarm = null;
            }
            if (thisFarm == null && useLocalFarm.Checked)
            {
                thisFarm = new AnalysisFarm(Convert.ToInt32(nbrEngines.Text), this);
                thisFarm.Start();
            }
            farmStartTime = DateTime.Now;
            totalAnalysis = new Dictionary<PositionHash, Analysis>();

            completedAnalysisRequests = 0;
            AnalysisIndexLabel.Text = "Current Analysis Index: 0";

            thisFarmClient = new AnalysisFarmClient(this);

            // thisFarm.AnalysisUpdateEvent += AnalysisEngine_AnalysisUpdate;   // probably not needed for this app...
            thisFarmClient.AnalysisCompleteEvent += AnalysisEngine_AnalysisCompleteV2;

            curAnalysisPositionIndex = -1;
            completedAnalysisRequests = 0;
            runningAnalysis = true;

            foreach (PositionHash ph in repetitionCount.Keys)
            {
                AnalysisRequest ar = new AnalysisRequest(globalEngineParameters, ph.Rehydrate());
                ar.MarkQueued();
                thisFarmClient.SubmitAnalysisRequest(ar);
            }


            /// lifetime of an analysis request
            ///     generated by farm client (should be before submit) from engine parameters and position (FEN, should just be the poshash) - status = Waiting
            ///     get submitted by a farm client (id generated there)
            ///     added to a list maintained by the farm client 
            ///     queued for execution by the farm
            ///     ----
            ///     pulled to a local list waiting for engine availablity (shouldn't be pulled from the queue until the engine is available...)
            ///         scheduling and general status is complicated by using AnalysisComplete for both NoPosition and AnalysisComplete, should be Idle
            ///     on engine availability, passed to engine, engineInstance is set, status = "In Process"
            ///         internally, the engine assigns the ar ID to an internal analysis object
            ///     on analysis complete, an ANALYSIS object (should be ar) is built from the engine analysis object
            ///     this analysisobject is queued for the farm client to pick up
            /// ----
            ///     on return, an analysis object is created by the farm clien and passed back to the calling app
            ///     the app then matches the analysis ID with the request id (position index, really) and stores the analysis result
        }
        void AnalysisEngine_AnalysisCompleteV2(AnalysisRequest ar)  // needs to refer to the actual analysis request...
        {
            UpdateAnalysisText(ar.thisAnalysis.ToString());

            TimeSpan runTime = DateTime.Now - farmStartTime;
            StoreAnalysis(ar);
            UpdateLabelText("Cur Index: " + (curAnalysisPositionIndex = ar.thisID).ToString() + " Ttl Rtnd: " + completedAnalysisRequests.ToString() + " Run Time: " + runTime.ToString());
        }
        delegate void SetTextCallback(string s);
        private void UpdateLabelText(string s)
        {
            if (AnalysisIndexLabel.InvokeRequired)
            {
                SetTextCallback d = new SetTextCallback(UpdateLabelText);
                Invoke(d, new object[] { s });
            }
            else
            {
                AnalysisIndexLabel.Text = s;
            }
        }
        private void UpdateAnalysisText(string s)
        {
            if (AnalysisIndexLabel.InvokeRequired)
            {
                SetTextCallback d = new SetTextCallback(UpdateAnalysisText);
                Invoke(d, new object[] { s });
            }
            else
            {
                lastAnalysisString.Text = s;
            }
        }

        private void AnalyzeViaEngine()
        {
            string EngineName = "Stockfish";
            AnalysisEngine = Engine.InitEngine(EngineName);

            AnalysisEngine.AnalysisUpdateEvent += AnalysisEngine_AnalysisUpdate;
            AnalysisEngine.AnalysisCompleteEvent += AnalysisEngine_AnalysisComplete;

            totalAnalysis = new Dictionary<PositionHash, Analysis>();

            curAnalysisPositionIndex = -1;
            completedAnalysisRequests = 0;
            runningAnalysis = true;
        }
        void AnalysisEngine_AnalysisComplete(int thisID)
        {
            if (AnalysisEngine != null && AnalysisEngine.curAnalysisRequest.thisAnalysis != null)
                lastAnalysisString.Text = AnalysisEngine.curAnalysisRequest.thisAnalysis.ToString();
            else
                if (AnalysisEngine != null)
                    lastAnalysisString.Text = AnalysisEngine.lastEngineReply;
        }
        void AnalysisEngine_AnalysisUpdate(int thisID)
        {
            if (AnalysisEngine != null && AnalysisEngine.curAnalysisRequest.thisAnalysis != null)
                lastAnalysisString.Text = AnalysisEngine.curAnalysisRequest.thisAnalysis.ToString();
            else
                if (AnalysisEngine != null)
                    lastAnalysisString.Text = AnalysisEngine.lastEngineReply;

            if (AnalysisEngine != null && AnalysisEngine.AnalysisComplete())
                ;
        }

        int lastSentHashCode;
        private void timer1_Tick(object sender, EventArgs e)
        {
            if (!runningAnalysis)
                return;

            if (UseFarm.Checked)
            {
                if (repetitionCount != null && completedAnalysisRequests == repetitionCount.Count && curAnalysisPositionIndex != -1)
                {
                    AnalyzeDeltas();
                    curAnalysisPositionIndex = -1;
                    if (thisFarm != null)
                        thisFarm.Shutdown();
                    thisFarmClient.Quit();
                    thisFarmClient = null;
                }
                return;
            }

            AnalysisEngine.CheckProgress();

            TimeSpan curAnalysisTime = DateTime.Now - curAnalysisStartTime;
            if (AnalysisEngine.AnalysisComplete())  // it actually finished something
            {
                System.Console.WriteLine("ran to the end!");
                StoreAnalysis(AnalysisEngine.curAnalysisRequest);
                if (completedAnalysisRequests >= repetitionCount.Count)
                {
                    runningAnalysis = false;
                    curAnalysisPositionIndex = -1;
                    AnalyzeDeltas();
                }
            }
            if (AnalysisEngine.Idle())  // it's ready to start something
            {
                if (runningAnalysis)    // start it if there's more to do...
                {
                    PositionHash nextHash = repetitionCount.ElementAt(++curAnalysisPositionIndex).Key;
                    Position nextPos = nextHash.Rehydrate();
                    if( nextHash.GetHashCode() != nextPos.Hash.GetHashCode() )
                        Console.WriteLine("uh oh - we're out of sync...");
                    lastSentHashCode = nextHash.GetHashCode();
                    StartAnalysisAsync(repetitionCount.ElementAt(curAnalysisPositionIndex).Key.Rehydrate());
                }
            }
            AnalysisIndexLabel.Text = "Current Analysis Index: " + curAnalysisPositionIndex.ToString();
        }

        private void FileStatsButton_Click(object sender, EventArgs e)
        {
            // how many games
            int totalGames = 0;
            int ratedGames = 0;
            int totalPlies = 0;
            foreach (Game g in GameRef)
            {
                // how many games
                totalGames++;
                // how many rated (class?)
                if (g.RatingWhite != Game.NoRating && g.RatingBlack != Game.NoRating)
                    ratedGames++;
                // how many plies
                totalPlies += g.Plies.Count;
            }
            // how many unique positions
            repetitionCount = IdentifyUniquePositions();

            TotalGamesLabel.Text = "Total Games: " + totalGames.ToString();
            TotalRatedLabel.Text = "Total Rated: " + ratedGames.ToString();
            TotalPliesLabel.Text = "Total Plies: " + totalPlies.ToString();
            UniquePosLabel.Text = "Unique Pos: " + repetitionCount.Count.ToString();
        }
        private Dictionary<PositionHash, int> IdentifyUniquePositions()
        {
            Game refStart = new Game();
            string refFEN = refStart.ToFEN();
            PositionHash refHash = new PositionHash(refStart.CurrentPosition);
            int refHashCode = refHash.GetHashCode();

            Dictionary<PositionHash, int> outCount = new Dictionary<PositionHash, int>();
            foreach (Game g in GameRef)
            {
                g.ResetPosition();
                PositionHash ph = new PositionHash(g.CurrentPosition);
                if (outCount.ContainsKey(ph))
                    outCount[ph]++;
                else
                    outCount.Add(ph, 1);

                foreach (Ply p in g.Plies)
                {
                    g.AdvancePosition();
                    ph = new PositionHash(g.CurrentPosition);

                    if( g.CurrentPosition.Hash.GetHashCode() != ph.GetHashCode() || g.CurrentPosition.Hash.GetHashCode() != ph.Rehydrate().Hash.GetHashCode())
                        Console.WriteLine("hash or rehydrate issue...");

                    if (outCount.ContainsKey(ph))
                        outCount[ph]++;
                    else
                        outCount.Add(ph, 1);
                }
            }
            return outCount;
        }
        private void StartAnalysisAsync(Position p)
        {
            curAnalysisStartTime = DateTime.Now;
            AnalysisEngine.CheckProgress();
            AnalysisEngine.StartAnalysis(globalEngineParameters, p);
        }

        private void AnalyzeForm_Load(object sender, EventArgs e)
        {
            curAnalysisPositionIndex = -1;
            AnalysisEngine = null;
            runningAnalysis = false;
            curAnalysisStartTime = DateTime.Now;
            posAnalysisTimeLimit = new TimeSpan(0, 0, 0, 0, 2000);
            nbrEngines.SelectedIndex = 3;

            if (PGNLoc.Text != "")
            {
                GameRef = Game.ReadPGNFile(PGNLoc.Text);
                FileStatsButton_Click(null, null);
            }

            timer1.Start();
        }


        private void StoreAnalysis(AnalysisRequest ar)
        {
            if( !UseFarm.Checked && ar.thisID != lastSentHashCode )
                Console.WriteLine("uh oh - we're out of sync...");

            // find the ph whose hash matches this arID
            PositionHash ph = null;
            foreach (PositionHash possPH in repetitionCount.Keys)
                if (possPH.GetHashCode() == ar.thisID)
                {
                    ph = possPH;
                    break;
                }
            Analysis analysis = ar.thisAnalysis;

            if (totalAnalysis.ContainsKey(ph))
                Console.WriteLine("uh oh - we're out of sync...");
            totalAnalysis[ph] = analysis;
            if (totalAnalysis.Count != ++completedAnalysisRequests)
                Console.WriteLine("uh oh - we're out of sync...");
            CatalogAnalysis(analysis, ph);
        }
        string analysisLogLocation = "C:\\HostWrapper\\analysis.txt";
        public void CatalogAnalysis(Analysis analysis, PositionHash ph)
        {
            string outString = "|" + new string(ph.hashValue) + analysis.ToQueueString();
            StreamWriter log = new StreamWriter(analysisLogLocation, true);
            log.WriteLine(outString);
            log.Flush();
            log.Close();
        }
        private void AnalyzeDeltas()
        {
            Analysis refAnalysis;
            Analysis newAnalysis;
            foreach (Game g in GameRef)
            {
                UpdateGameDigest(g.RatingWhite, g.RatingBlack, g.Plies.Last().MoveNumber);
                g.ResetPosition();
                while (!g.EndOfGame)
                {
                    refAnalysis = totalAnalysis[g.CurrentPosition.Hash];
                    int MoveNumber = (g.curPly / 2) + 1;

                    g.AdvancePosition();
                    newAnalysis = totalAnalysis[g.CurrentPosition.Hash];
                    decimal delta = Math.Abs(refAnalysis.Score - newAnalysis.Score);
                    bool blunder = IsThisABlunder(MoveNumber, delta, refAnalysis.Score);

                    g.AdvancePosition(-1);
                    WriteMoveResult(g.OnMove, MoveNumber,
                        g.OnMove == PlayerEnum.White ? g.RatingWhite : g.RatingBlack,
                        g.OnMove == PlayerEnum.White ? g.RatingBlack : g.RatingWhite,
                        delta,
                        blunder);
                    g.AdvancePosition();
                }
            }
        }
        string logLocation = "C:\\HostWrapper\\deltas.txt";
        public void WriteMoveResult(PlayerEnum onMove, int moveNbr, int moveRating, int oppRating, decimal delta, bool isBlunder)
        {
            string outString = String.Format("|{0}|{1}|{2}|{3}|{4}|{5}|",
                (onMove == PlayerEnum.White ? "w" : "b"), moveNbr, moveRating, oppRating, delta, (isBlunder ? "Y" : "N"));
            // ### we can aggregate them however we want from here...
            StreamWriter log = new StreamWriter(logLocation, true);
            log.WriteLine(outString);
            log.Flush();
            log.Close();
        }
        public void UpdateGameDigest(int RatingWhite, int RatingBlack, int MoveCount)
        {
            // ### we can aggregate them however we want from here...
        }

        private bool IsThisABlunder(int move, decimal delta, decimal incomingScore)
        {
            // this is somewhat subjective
            // con something be a blunder if it still leads to a dead won game (simplification)?
            // is something a blunder if you're dead lost (trying for counterplay)?
            // should your move be counted as "not a blunder" for stats if it's book or tablebase bound?
            // does engine analysis even matter for "book" lines...
            // do exhibition or skittles games matter, or only rated events?

            // store the delta and the subejective flag
            // 0 = not a tumor, 1 = simplification, 2 = counterplay, 3 = book

            bool blunder = delta >= 2.5m;
            if (blunder)
                Console.WriteLine("got one...");
            return blunder;
        }

        private void AnalyzeForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (thisFarmClient != null)
                thisFarmClient.Stop();
            if (thisFarm != null)
                thisFarm.Shutdown();

            thisFarmClient = null;
            thisFarm = null;
        }

    }
}
